 Language is for communication. Programming language, of course, is primary used to communicate with computers. In order to understand programming language, we need to know a little bit about computer. And when we look at the base model of computer, which essentially is called a Turing machine, and it has infinite tape, and you can store a sequence of zero once on the infinite tape, which can store the state. And by changing the zero once bits, and you perform some kind of state transition. And that is achieved by a read and write head, which moves around the tape. And of course, you also have programs, which are also zero once sequences across. There is some encoded the zero once sequence, which defines a specific meaning. And we use that to actually change the content of tape. For example, we shift to the data part, and it makes some actions. Then they have to move back to the data part, and then try to fetch the instructions. Then we'll back to the data part to make modifications. Of course, it's very inefficient in some sense, and it's a very difficult for humans to understand. That's why we need to have modern computers, and modern computers, of course, capture the same idea as a Turing machine. For example, the infinite tape now is abstract by memory, and the read and write head and control movements, basically relies on the CPU, and to make the access and law efficient, we instead move in the head and around, we can send the data around, so we use the bus. So in order to communicate with the computer, we have to have some instructions to tell the computer what to do. So that's why we start to have the first generation of programming languages, which we call machine language, which are meaningful machine instructions that computer can understand. And the first machine language, of course, occurred in the way we have the first program, the U.S. Term Computer, which was developed at the University of Pennsylvania in 1945. Ever to manipulate the machine language, especially right in the program, in machine languages, is very difficult and very inefficient, and our problem, so we start to have something called Samuel Language, which is characterized by second generation language. Yeah, Samuel Language used symbolic notations, for example, if it's add instead of let's say 1-0, which encode the action, we can't just write add ADD, and of course that is better for human to understand. However, which is still a little level, and we want to communicate more ideas, more abstract concepts, and to tell whatever computer wants to apply for us. Okay. So that's why we need to have more powerful programming languages and make them more expressive, understandable, to human. And we do this by abstraction, we call these language high-level programming languages. And the evolution basically is the control for all, and the data for all, and also a functional procedural abstraction. Okay, so it's got to have these program languages which have these go to statement, if statement, loop statement, and they have procedures, functions, and these languages actually occur in late 50s. Okay, the first, actually high-level language is called Hortron, which was developed by IBM in 1958. So that's the first third generation program language. And our basically strive for more expressiveness and understandability keeps going. Okay, so in early 90s, early 80s, we have something called an object-guarding, a language, and some small hawk, which is the first object-guarding language. And in the end, we also have a language, for example, a veriformy, I would say Java, C++, and so on, so forth. Okay, so that is considered as false-generation language, as well as other languages like logic languages. Okay, so we do abstraction, so we have something called prologue, which is a very popular logic program language in early 80s, and actually that pushed a movement by a Japanese government as the fifth generation computers, which tried to support this language directly, but it didn't go very well. And of course, nowadays, we want to generate programs even without right programs. Okay, so we have these program-generation use AI, for example, use chat GPT, and let's just call that fifth-generation language, which start right at the moment. Okay, so we designed different languages because we tried to find the most pressing this, more understanding, and of course, that also has a special purpose, for example, we want to make the language more reusable and secure, and so we have object-guarding in a language, for example, where we can't reuse the classes, and at the same time class provides some encapsulation, and give you the control of visibility, which ensures the security of the data to be accessed by which part of the program, and so you can't put the controls to make the program osc.c. And another reason is we want to address different application needs, for example, some numerical computation, very lonely on computer design for numerical computation. So we have this four-trend, which basically is combined order for formula translation, and then for data processing, we have a language called a cobalt, nowadays you don't see, it's mentioned in animal, but in 60s, 70s, and even 80s was a major programming language for data processing, and then we also have general-purpose language and specific target language. Okay, so these language are designed for different needs, and there are other reasons for design these different language to make them more efficient, and better fit for hardware such as concurrents, actually, sometimes it's other way around, because we design both powerful languages, then we actually develop hardware to support them. For example, like a pass-on language, okay, which is a very good form of machine learning, and so we develop a GPU, like it's a CPU to help to process the graphics law efficiently. And another reason, of course, is from the big power factor of language, for example, Aida is a very popular language, actually studied in 80s, which is supported by the defense of the product of defense of the United States. So for these different reasons, we have many different programming languages, okay, so how many language sounds here? We don't know, definitely thousands of languages, okay, but fewer of the kind for popular slides. So the reason to have long-lasting impact is a language need to be easy to learn, and easy to use, and easy to implement at the same time it needs to be powerful enough to help us to express what we want to communicate to the computer. At the same time, of course, when we talk about the language, the primary goal of language is programming language to communicate with computer, but at the same time, we also want language to be an example to our fellow software developers, because we don't understand or we often work on big projects, okay, and we can't have multiple paths and involve many, many people over a million years. So you have code maybe read, shared by others, and others code maybe shared with you. You may also inherit the code from some lag system, which developed a year ago. So if the language, the program's not a rickety in the language of understanding, you will definitely have a very difficult time to understand what's going on, okay. So that's a reason some language don't last a very long, but other languages, you know, become popular, okay. So now we know that many of the language there, and of course in this class, we have not been to all of these, but we go to look at the some generic features among these different languages, okay. For example, the language you have learned, they're like a Java and other languages, and so we go to look at what you have learned, and also we're going to look at some other stuff, languages, for example, in this class, we go to learn a functional programming language, which is a shop, and we're going to look at how it's unique, how it's different from what you have learned in other classes, and give you a perspective of, you know, how you can attack the problem, or solve the problem in different style, in different the way of thinking, and then have some kind of comparison, and have to understand that these different features are much better, okay. So in general, how we look at these thousands different languages, okay. So that essentially, two major categories we can put these language in, of course, the other dimensions, but these are like two major categories. First type of language we call imperative, okay. So what are the characteristics of imperative languages, okay. So basically, in this type of language, you define variants, okay. So what are variable four? Essentially, variables are a way actually for us to say this is information, we need to be stored, and essentially, that is actually a state we're talking about, okay. So if we still remember, we talk about tuning machine, we have a tape, right. If we look at a modern computer, we have memory, okay. So in higher level programming language, we are not going to say, you know, where in the memory we're going to put what value, okay. So we define variables, and the variables essentially will be translated into memory location, and so the values of variables will be what's stored in those memory locations, of course. We don't need to specify where to be put, and actually that will be more dynamically efficiently managed by the operating system, okay. So the comparison will say how much space this variable occupies, and then actually the memory management process in the operating system will put where the space is available, to be utilized by this program, okay. So variable size essentially mapping from memories to the values, okay. And then how do we do state change? State change is essentially a silent state, okay. So basically we express the manipular variables, so they can be used to change a factor program results. And so using the variables actually, we try to compute some sin by small step change, okay. So we use the cumulative effects of variables to achieve the final results, okay. So you can see more details will be involved. Then there's another class of programming languages we call decorative language, so applicative sometimes also called. So in this type of language, there's no explicit state change. That is actually we don't define variables. And how that can be accomplished, essentially we do major step computation. We don't use the minus state change to accumulate the program result. Actually we do major step computation, and then we direct at the result, okay. So you will see actually what we discuss, the functional programming language f-shop, basically we don't define variables, and we try to get the results by using some sin code of functions and function composition. So keep in mind, okay. So also there are solutes of language, and you can roughly classify, I'll put these language into these two categories, imperative and decorative. Of course, their language is which we call multi-paradach. That means they have features in both categories, okay. So in this case, of course, you can't really strengthen this language, not to be imperative or decorative, but example, even f-shop, which is multi-paradach programming language. So in our class, of course, we only restrict ourselves to the decorative part of it, so we want to look at a functional aspect of it. And another example is like a Python language, okay, which is also multi-paradach program language, so you can use the features which we stack derivative part, as well as in perfect part. So now we have some ideas about the programming languages and the evolutions, and we also know why there are reasons for these different languages, and what are the major categories of these languages. Now, why do we set a programming language? Of course, there are many different reasons, okay. As a user, you want to have some idea about the one language you can't use for your specific purpose, for example, if you want to solve problem and you want to find a suitable language, which is best suitable for that particular task, okay. So that's one thing, and of course, once you understand a programming language, it will be very easy to learn another programming language, especially within the same class. For example, if you have Java, you already learn these control structures and data abstractions, and the plus concept of the object orientation, it will be much easier to learn another one, let's say, C++, and which you can find as similar concepts, but maybe different notation. So, so you are only, the event here is trying to adapt yourself to get familiar with these different notation, but conceptually, you have no problem to understand these different features. And then, of course, if you learn a language so you can't even you know this language, you become a better user because you can understand some features of this language who have these advanced this may have these problems as well, and so you can choose a proper eight features to solve a problem. For example, if you want to efficiency, you will do certain things if you want to security, you do certain things, okay. So, give you a much better, comprehensive understanding of overall language, okay. Then, of course, if you end up with designing a new language, so now you want to understand that these different, you know, features of language, different the pro-anacons of languages, and you can select, you know, probably features to make up your own language. And finally, if you are involved in imprim language, and then you have a better idea about the what kind of features will be causing certain problems, what kind of features can be imprimmed using what kind of technology, okay. So, that different perspective once you understand that, you know, general ideas of program language design, implementation, and use, and you can do all these things, or impact them. Finally, let's look at how we actually define a language and an imprim language, okay. So, a pro-anac language has essentially two parts, has syntax that is the form, that's a structure, okay. So, of course, you first need to understand you have to have proper structures before you can understand the meaning, okay. So, when we try to define a program language, use something called a grompers, okay. And which are the rules that will tell you exactly how to put the program together, okay. For example, you have if, then you need to follow the logic expression, then then some kind of statement or expression, okay. So, you need to have proper others, and then cross in specific language, you have these keywords, which you all separate these different entities. And in this class, actually, we are going to look at some type of grompers, which are used to define the tokens, in this lecture, we are going to discuss context to discuss context free ground up to discuss context free barmer and parse and discuss context free barmer and parsing. Context free barmer, so you essentially lose to find syntax or programming languages, thus the program generators. Parsers on the other hand, push the term that recognize the language defined by context free bar. All program structure, okay. And then, of course, we also need to understand that once we have this form, we need to understand its meaning. So, we're going to learn different techniques to define something called the semantics, meaning basically semantics, okay. So, when we look at program, actually the semantics can be defined as something called a static semantics and a dynamic semantics, okay. I want you to keep that in mind. The static versus dynamic, and this actually used in many different contexts throughout the semester, you will see in different contexts, you will see that. And what is the dividing line of static and the dynamic, okay. Essentially, whatever which can be determined or defined, decided before the program execution, which is called a static. And whatever need to be determined during program execution, which is dynamic, okay. So dynamic means program execution static means before program execution, okay. So, very well, okay. So, you will see later, static semantics essentially can be determined before program execution. These are information, but the verbal types, for example, and a number of parameters, and so on, so forth, okay. So, this tells you what this verbal is about, the type tells you that, okay. So, that's about the same meaning. So, you can't have to ask if it's a type 8, it means something different than if it's type, prompt or real. And dynamic semantics, how to define them, actually, the many different techniques used to teach a wider level course called semantics of programming languages. There are different ways you can define dynamic semantics. For example, you can use something called operational semantics, when you see operational, essentially, you abstract that as like a machine, of course, as much high level than to a motion. And then there's something called axiomatic semantics. I essentially use axioms to define the meaning of states. So, there's also algebraic semantics, okay. So, you use algebra to define semantics. So, there are different ways to define the dynamic semantics, and these techniques are not going to be covered in the class. Okay, so, we're going to just define some very simple techniques, we're going to look at which are going to be used for defined simple static semantics in this class. And then, finally, so, we look at the programming language, we say, you know, it's primary reason is for machine understanding, okay. So, we're basically writing programs for machine to understand. But at the same time, we also want to write programs for human to understand. And if you look at the evolution of programming language from first generation, the machine code, machine language to high level language, which essentially for human to understand, okay. With very high abstractions, which we can use to direct express our ideas. There's a huge gap between the high level languages to the machine language, okay. So, how do we deal with that? Okay, so we have special software, which will help us to bridge this gap. Okay. These are called comparrs or interpreters. So, comparrs essentially translate a programming high level language to low level language. Okay, can be assembly, some intermediate code of direct to a machine code. And then, once you have that translate the program, you can't ask it, okay. So, when you talk about comparrs, there are two different stages, okay. So, you have a translation part, then you have execution part. However, when you have interpreters, and basically you take the program, you try to understand at the same time you try to execute it. Okay. So, it has a single process essentially. And there are pro-anacons of comparrs and interpreters. So, in next lecture, we are going to briefly look into a little details of comparrs and interpreters. Okay, thank you.